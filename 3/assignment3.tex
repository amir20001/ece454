\documentclass{article}
\usepackage{siunitx}
\usepackage{mathtools}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{amssymb}
\sisetup{load-configurations = abbreviations}

\usepackage{fullpage}

\begin{document}

\begin{center}
\textsc{\Large ECE 454 Assignment 3}\\[0.5cm]
\textsc{Amir Benham 20393292, Andrew Svoboda 20369388}\\[0.5cm]
\end{center}

\begin{enumerate}

	\item  

By contradiction. Graph \(G\) exists where the vertices of \(S\) are disconnected from each other. That is, there is more than one edge between any one of the vertices of \(S\). If there exists a subtree of an MST of \(G\) that contains all of \(S\), then there must be at least one or more nodes of \(G\) in the subtree, indicating that the subtree cannot be a steiner tree of \(S\).

	\item 
	By induction. Where the hypothesis is: a connected graph with one node has no edges.
	
	When there are \(k\) nodes, we have there are \(k-1\) edges. Show that with \(k+1\) nodes, there are \(k\) edges. 

	We can say that a connected graph \(G\) has \(k+1\) nodes, and take one of the leaf nodes of the tree. We know that a leaf node can only have one edge. If we remove this leaf node and corresponding edge, \(G\) is still a tree. Thus, \(G\) now has \(k\) nodes, and \(k - 1\) edges.

	In effect, if one removes each node and the associated edge, then at the end there will only exist the root node without any other edges. 

	\item 

		By contradiction. \(T\), the MST of \(G\) contains the vertices \(u\) and \(v\). We know that because \(T\) is an MST, there is at least one path from \(u\) to \(v\). If \((Q, V / Q\)) is a cut of \(G\), then the cut must cross one edge of \(T\). If however the cut crosses more than one edge of \(T\), then there must exist a cycle within \(T\), which would then imply \(T\) could not possibly be an MST.


	\item 

	\begin{enumerate}
		\item There are two client processes operating, \(P_a\) and \(P_b\). \(P_a\) requests a read of file \(f\) at time 1.  \(P_b\) requests to write to file \(f\) at time 2. The UNIX notion of correctness states that the read will occur and return the last state of the file, before \(P_b\)'s changes take effect. However, if there is a large delay such that the write of \(P_b\) takes effect before \(P_a\), then \(P_a\) will see the file as it was changed, while operating under the assumption that no such change is in effect.

		Alternatively, this question could be interpreted in the following manner. If the same processes above, \(P_a\) and \(P_b\), both attempt a write operation of the same file at the same time, we can construct a situation where UNIX correctness fails. If \(P_a\) begins the write first, and \(P_a\) finishes the write after \(P_b\), then \(P_b\)'s write will override that of \(P_a\). Essentially the OS uses the start time of the write to assert which should be treated as the correct write, rather than the last write of the file. 

		\item By instead using the end time of the successful write, rather than the start time, to determine the correct write the notion of UNIX correctness is met.

		\item When a start transaction is received by the server we will associate an id and a time with the user's transaction. When a user tries to write to a file, the server will store the changes to the file with out committing it. When a client tries to read a file the server will just keep a list of files that need to be read. When the server receives the end transaction it should look at all the files that are being accessed and if any of them have been modified since the transaction started the transaction will fail and none of the changes will be committed and nothing will be return to the user. On the other hand if no changes have been made everything should be committed and the requested data should be returned to the client.
	\end{enumerate}

	\item There is a skew of 10 ticks per millisecond which results in 10,000 tick skew per second and 600,000 per minute. This translates to a clock skew of 600 milliseconds.

	\item  Yes, every message must be acknowledged since the message will not be passed to the application if all other processes have acknowledged the message. This is required to guarantee that all the processes will have the same message queue.
\end{enumerate}

\end{document}
